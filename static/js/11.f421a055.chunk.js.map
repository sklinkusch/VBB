{"version":3,"sources":["components/StopBody.js"],"names":["__webpack_require__","r","__webpack_exports__","d","StopBody","react__WEBPACK_IMPORTED_MODULE_0__","react__WEBPACK_IMPORTED_MODULE_0___default","n","_helpers__WEBPACK_IMPORTED_MODULE_1__","StopName","lazy","e","then","bind","Error","TableData","_ref","stop","data","error","_ref$mode","mode","newData","myData","resultArray","lowestValue","undefined","length","filtered","lowestResult","name","highestValue","i","slice","push","splitArray","sort","a","b","toLowerCase","sortingArray","indexOf","line","product","sortData","keyword","text","concat","getDuration","type","createElement","Fragment","element","map","depset","index","key"],"mappings":"0FAAAA,EAAAC,EAAAC,GAAAF,EAAAG,EAAAD,EAAA,4BAAAE,IAAA,IAAAC,EAAAL,EAAA,GAAAM,EAAAN,EAAAO,EAAAF,GAAAG,EAAAR,EAAA,IAEMS,EAAWC,eAAK,kBAAMV,EAAAW,EAAA,IAAAC,KAAAZ,EAAAa,KAAA,YACtBC,EAAQJ,eAAK,kBAAMV,EAAAW,EAAA,IAAAC,KAAAZ,EAAAa,KAAA,aACnBE,EAAYL,eAAK,kBAAMV,EAAAW,EAAA,IAAAC,KAAAZ,EAAAa,KAAA,aAEd,SAAST,EAATY,GAAuD,IAAnCC,EAAmCD,EAAnCC,KAAMC,EAA6BF,EAA7BE,KAAMC,EAAuBH,EAAvBG,MAAuBC,EAAAJ,EAAhBK,YAAgB,IAAAD,EAAT,MAASA,EA0D9DE,EAvBa,SAACC,GAClB,IAAIC,EAAc,GACdC,EAAc,EAClB,QAAeC,IAAXH,EACF,OAAO,KAET,KAAOE,EAAcF,EAAOI,QAAQ,CAIlC,IAHA,IAEIC,EAFAC,EAAeN,EAAOE,GAAaR,KAAKa,KACxCC,OAAY,EAEPC,EAAIP,EAAaO,EAAIT,EAAOI,OAAQK,IAC3C,GAAIT,EAAOS,GAAGf,KAAKa,OAASD,EAAc,CACxCE,EAAeC,EACf,MAGJJ,EAAWL,EAAOU,MAAMR,EAAaM,GACrCP,EAAYU,KAAKN,GACjBH,EAAcM,EAEhB,OAAOP,EAGOW,CAzDC,WACf,GAAa,OAATjB,QAA0BQ,IAATR,GAAsBA,EAAKS,OAAS,EACvD,OAAOT,EAAKkB,KAAK,SAACC,EAAGC,GACnB,GAAID,EAAEpB,KAAKa,KAAKS,cAAgBD,EAAErB,KAAKa,KAAKS,cAC1C,OAAQ,EACH,GAAID,EAAErB,KAAKa,KAAKS,cAAgBF,EAAEpB,KAAKa,KAAKS,cACjD,OAAO,EAEP,IAAMC,EAAe,CACnB,UACA,WACA,WACA,SACA,OACA,MACA,SAEF,OACEA,EAAaC,QAAQJ,EAAEK,KAAKC,SAC5BH,EAAaC,QAAQH,EAAEI,KAAKC,UAEpB,EAERH,EAAaC,QAAQH,EAAEI,KAAKC,SAC5BH,EAAaC,QAAQJ,EAAEK,KAAKC,SAErB,EAEA,IA4BEC,IAMbC,EAAmB,QAATxB,EAAiB,aAAe,WAC1CyB,EAAO7B,EAAI,eAAA8B,OACEC,YACb/B,EAAKgC,MAFM,iBAAAF,OAGIF,EAHJ,uEAAAE,OAIEC,YACb,OALW,iBAAAD,OAMIF,EANJ,wDAOjB,OACEvC,EAAA+B,EAAAa,cAAC5C,EAAA+B,EAAMc,SAAP,KACGlC,GAAQX,EAAA+B,EAAAa,cAACzC,EAAD,CAAUQ,KAAMA,EAAMmC,QAAQ,OACtCjC,EACCb,EAAA+B,EAAAa,cAACpC,EAAD,WACcY,IAAZJ,GAAqC,OAAZA,GAAoBA,EAAQK,OAAS,EAChEL,EAAQ+B,IAAI,SAACC,EAAQC,GACnB,OAAOjD,EAAA+B,EAAAa,cAACnC,EAAD,CAAWE,KAAMqC,EAAO,GAAGrC,KAAMC,KAAMoC,EAAQE,IAAKD,EAAOlC,KAAMA,MAG1Ef,EAAA+B,EAAAa,cAAA,WAAMJ","file":"static/js/11.f421a055.chunk.js","sourcesContent":["import React, {lazy} from \"react\"\nimport { getDuration } from \"./helpers\"\nconst StopName = lazy(() => import(\"./StopName\"))\nconst Error = lazy(() => import(\"./Error\"))\nconst TableData = lazy(() => import(\"./TableData\"))\n\nexport default function StopBody({ stop, data, error, mode = \"dep\" }) {\n  const sortData = () => {\n    if (data !== null && data !== undefined && data.length > 0)\n      return data.sort((a, b) => {\n        if (a.stop.name.toLowerCase() < b.stop.name.toLowerCase()) {\n          return -1\n        } else if (b.stop.name.toLowerCase() < a.stop.name.toLowerCase()) {\n          return +1\n        } else {\n          const sortingArray = [\n            \"express\",\n            \"regional\",\n            \"suburban\",\n            \"subway\",\n            \"tram\",\n            \"bus\",\n            \"ferry\",\n          ]\n          if (\n            sortingArray.indexOf(a.line.product) <\n            sortingArray.indexOf(b.line.product)\n          ) {\n            return -1\n          } else if (\n            sortingArray.indexOf(b.line.product) <\n            sortingArray.indexOf(a.line.product)\n          ) {\n            return +1\n          } else {\n            return 0\n          }\n        }\n      })\n    return undefined\n  }\n  const splitArray = (myData) => {\n    let resultArray = []\n    let lowestValue = 0\n    if (myData === undefined) {\n      return null\n    }\n    while (lowestValue < myData.length) {\n      let lowestResult = myData[lowestValue].stop.name\n      let highestValue\n      let filtered\n      for (let i = lowestValue; i < myData.length; i++) {\n        if (myData[i].stop.name !== lowestResult) {\n          highestValue = i\n          break\n        }\n      }\n      filtered = myData.slice(lowestValue, highestValue)\n      resultArray.push(filtered)\n      lowestValue = highestValue\n    }\n    return resultArray\n  }\n  const sortedData = sortData()\n  const newData = splitArray(sortedData)\n  // const text = `In the next ${getDuration(\n  //   stop.type || 'BLN'\n  //   )} minutes, no departures are planned for the station or stop you have\n  //   chosen.`;\n  const keyword = mode === \"dep\" ? \"departures\" : \"arrivals\"\n  const text = stop\n    ? `In the next ${getDuration(\n        stop.type\n      )} minutes, no ${keyword} are planned for the station or stop you have chosen`\n    : `In the next ${getDuration(\n        \"BLN\"\n      )} minutes, no ${keyword} are planned for the station or stop you have chosen`\n  return (\n    <React.Fragment>\n      {stop && <StopName stop={stop} element=\"h2\" />}\n      {error ? (\n        <Error />\n      ) : newData !== undefined && newData !== null && newData.length > 0 ? (\n        newData.map((depset, index) => {\n          return <TableData stop={depset[0].stop} data={depset} key={index} mode={mode} />\n        })\n      ) : (\n        <div>{text}</div>\n      )}\n    </React.Fragment>\n  )\n}\n"],"sourceRoot":""}